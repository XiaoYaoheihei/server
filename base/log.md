## 日志库的分析

### 重要性

服务端编程，日志必不可少，生产环境中应该做到每一个时刻都记录着服务器发生的状态。

一个日志库大体上分为日志库前端（Logging）和日志库后端（LogFile)两个部分。前端部分是供应用程序调用的接口，进而生成日志消息；而后端部分负责把日志消息写入日志文件。

在多线程程序中，**每一个线程都有自己的日志“前端”部分，而整个程序共用一个“后端”部分，难点在于将日志数据信息从多个前端高效的传输到后端！！！**这是一个典型的多生产者---单消费者问题：
- 对于生产者而言，要尽量做到低延迟，低CPU开销，无阻塞；
- 而对于消费者而言，要做到足够大地吞吐量，并占用较少资源。


### 日志库的功能需求

- 多种日志级别可配置
- 日志输出目的地只能是本地文件
- 支持日志文件rooling（如按天、按大小），以简化日志归档
- 日志文件命名（进程名+创建日期+创建时间+机器名+进程id+后缀log）
- 日志消息格式固定（日期+时间+线程id+日志级别+源文件名和行号+日志信息

### 日志库的性能需求

- 每秒写千万条日志无明显性能损失
- 能应对一个进程产生大量日志数据的场景
- 不阻塞正常的执行流程
- 在多线程程序中，不造成争用
- 可以瞬时写满磁盘带宽


## 日志库的实现方案探讨

### 方案一：每次日志操作打开、写、关闭文件一次
每一次日志操作，都进行三个步骤：打开文件、写文件、关闭文件。
当写入日志频率高时，磁盘IO占用高；
低延迟的操作中，IO效率导致延迟高；

非常明显，多线程中这种反复打开关闭文件是没有意义的！！！！

### 方案二：每次日志操作写一次文件，文件全局打开一次
程序启动是打开文件，后续日志操作就对文件写一次。
文件操作默认是存在一定缓冲区，写当入字节总量达到一定值，才操作一次磁盘。因此，在单线程中当前方案相对于方案1有极大的效率提升。

在日志操作不频繁、消息短小时，方案2是可行的。

需要注意的是：**使用c++中std::ostream的方式是不正确，因此其非线程安全，会导致日志消息交织混乱，除非加锁。 而c的fwrite是线程安全的多个线程中不加锁直接使用，但是日志数消息也会出现交织混乱。**


### 方案三：减少磁盘IO操作次数
为了提高效率，需要尽量减少磁盘IO的操作。例如，可以**使用一个线程安全的队列，一边负责写日志消息，另一边负责取消息日志。**当取消息日志条数或者总长度达到一定的数量，我们才写一次磁盘，整体上来可以降低磁盘IO的操作次数。

1.一种可行的方案是，使用::setbuffer函数将文件的缓冲区设置大一些。**这相当于是在内核层面直接修改。**
2.另一种方案是使用队列。但是使用队列需要保证每条日志消息的完整性，也就是需要使用互斥锁来保证，这样会有小量的性能损耗；若在使用BlockingQuene时每次产生一条消息时都需要通过条件变量通知接收方，性能会有进一步的损耗。
在多线程中，队列已经保证了单条日志的完整性，不会出现交织情况。在**使用队列存储日志消息到磁盘时，实际是单线程的操作**，可以使用fwrite非加锁版本::fwrite_unlocked函数进一步提高效率。


### 方案四：使用缓冲技术（在用户层面）
方案3中，**队列保证消息正确性和完整性**，可以使用::fwrite_unlocked函数提高日志性能。
如果使用::setbuffer函数将缓冲区设置大一些，使用一种不带锁的"线程安全队列"，同时
也能使用::fwrite_unlocked函数写磁盘操作，那么多个环节效率就可以兼顾了。

## muduo日志库的设计思路
多个线程共用一个日志前端，使用多缓冲。基本思路是准备多块Buffer，前端部分向Buffer中填数据，后端负责将Buffer中的数据取出来写到文件中。
实现的好处在于新建日志的时候不必等待磁盘IO操作返回结果，是异步的，线程往前端写的时候也不会阻塞！！

举个例子：使用双缓冲技术，准备两块缓冲A和B，缓冲A接收日志消息，缓冲B将日志消息写入磁盘。当A写满，交换A和B，后端将B写入磁盘文件，前端则往A写写的日志消息，如此反复。

### muduo的日志库结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210718145242686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdnYW9fMTk5MA==,size_16,color_aaaaaa,t_70)

#### 日志库的前端（Logger）：

- LogStream类

主要作用是重载<<操作符，流式化日志输出方式。将基本类型的数据格式成字符串通过append接口存入LogBuffer中。格式化整形数据使用了优化方法。

- Logger类

提供设置日志级别和输出目的地的静态方法，使用LogStream的<<操作符将文件名，日志级别，时间等信息格式好提前写入LogBuffer中。日志默认级别Logger::INFO，默认输出到stdout。

- Impl类

是Logger类的私有类，为了隐藏实现，在用户消息输入到缓冲前，添加日期、时间、级别、线程固定前缀字段，添加当前日志消息出处的源文件、行数等固定后缀字段。

- Buffer类

用于前端手机用户日志消息的缓存，是模板类FixedBuffer<>的实例化，默认缓存4000字节。



#### 日志库的后端（LogFile）：

- LogFile类

日志文件管理类。以固定方式生成文件名并创建日志文件。实现日志滚动、日志缓存flush到日志文件的策略。

日志消息记录长度达到设定值、日志记录时间到达第二天进行日志滚动。当短时间内日志长度较小时，不能将日志信息长时间放如缓存中，因此日志每记录1024次数就检查一次距前一次flush到文件的时间是否超过3s，若是则flush到文件中。另外，可以选择是否使用互斥锁锁保证线程安全。

- AppendFile类

是 LogFile 类的成员，最终用于**操作本地日志文件**的类，输出缓冲区大小64k字节。非线程安全的，目的是提高效率。



#### 多线程异步日志类AsyncLogging

考虑多线程下各种性能要求实现的一个非阻塞日志功能实现。前端仍然是Logger，**只是将默认日志输出从stdout重定向到了AsyncLogging中。**

使用多缓冲技术，将输入缓冲、输出缓冲做高效的安全交换，供后端LogFIle写入到文件。

#### 日志消息格式化的优化措施

- 时间戳字符串中的**日期和时间是缓存的**，一秒之内的日志只需要格式化微秒部分。见Logger::Impl::formatTime()实现。

- 日志消息的前4个字段是定长的，避免运行期求字符串长度（不用反复调用strlen）。编译器认识memcpy函数，**对于定长的内存复制，编译期将inline内联展开成高效的年目标代码。**见class T类的 Logstream& operator<<(LogStream& s, T v)函数。

- 线程id是预先格式化缓存的字符串，输出日志消息只需要拷贝几个字节。见Currendthread类介绍。

- 每条日志消息的源文件名和行数**通过编译期**计算得到（strrchr），避免运行时的开销。实际是使用日志宏语句，替换得到当前代码所在的 __FILE__, __LINE__字符串。

  见SourceFile类。

